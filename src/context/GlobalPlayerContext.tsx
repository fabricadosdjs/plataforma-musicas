'use client';

import React, { createContext, useContext, useState, useRef, useCallback, useEffect } from 'react';
import { Track } from '@/types/track';
import { useSession } from 'next-auth/react';
import { useToastContext } from '@/context/ToastContext';

interface GlobalPlayerContextType {
    currentTrack: Track | null;
    isPlaying: boolean;
    playlist: Track[];
    currentTrackIndex: number;
    playTrack: (track: Track, newPlaylist?: Track[]) => Promise<void>;
    pauseTrack: () => void;
    stopTrack: () => void;
    togglePlayPause: () => void;
    nextTrack: () => void;
    previousTrack: () => void;
    audioRef: React.RefObject<HTMLAudioElement>;
}

const GlobalPlayerContext = createContext<GlobalPlayerContextType | undefined>(undefined);

export const GlobalPlayerProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const { data: session } = useSession();
    const { showToast } = useToastContext();
    const [currentTrack, setCurrentTrack] = useState<Track | null>(null);
    const [isPlaying, setIsPlaying] = useState(false);
    const [playlist, setPlaylist] = useState<Track[]>([]);
    const [currentTrackIndex, setCurrentTrackIndex] = useState(-1);
    const audioRef = useRef<HTMLAudioElement>(null);

    const getSecureAudioUrl = async (track: Track): Promise<string | null> => {
        const audioUrl = track.downloadUrl || track.previewUrl || track.url;
        if (!audioUrl) return null;

        // Detectar se √© dispositivo m√≥vel
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // Em mobile, usar URL direta da Contabo (sem assinatura)
        if (isMobile && audioUrl.includes('contabostorage.com')) {
            console.log('üéµ GlobalPlayer: Mobile detectado - usando URL direta da Contabo');
            return audioUrl;
        }

        // Se a URL j√° √© uma URL segura (assinada), use-a
        if (audioUrl.includes('X-Amz-Signature')) {
            return audioUrl;
        }

        // Se √© uma URL do Contabo e √© desktop, tente obter uma URL segura
        if (audioUrl.includes('contabostorage.com') && !isMobile) {
            try {
                // Extrair o caminho completo do arquivo da URL
                // Exemplo: https://usc1.contabostorage.com/211285f2fbcc4760a62df1aff280735f:plataforma-de-musicas/community/DEORRO%20Y%20VOCES%20DEL%20RANCHO%20-%20CAMARON%20PELAO%20MAIN.mp3
                // Precisamos extrair: community/DEORRO%20Y%20VOCES%20DEL%20RANCHO%20-%20CAMARON%20PELAO%20MAIN.mp3

                // Encontrar o √≠ndice ap√≥s "plataforma-de-musicas/"
                const bucketPattern = 'plataforma-de-musicas/';
                const bucketIndex = audioUrl.indexOf(bucketPattern);
                if (bucketIndex !== -1) {
                    const key = audioUrl.substring(bucketIndex + bucketPattern.length);
                    console.log('üéµ GlobalPlayer: Desktop - extraindo chave do arquivo:', {
                        originalUrl: audioUrl,
                        extractedKey: key,
                        bucketPattern,
                        bucketIndex
                    });

                    const response = await fetch(`/api/audio-url?key=${encodeURIComponent(key)}`);
                    if (response.ok) {
                        const data = await response.json();
                        console.log('üéµ GlobalPlayer: URL segura obtida:', data.url);
                        return data.url;
                    } else {
                        console.error('üéµ GlobalPlayer: Erro na API audio-url:', response.status, response.statusText);
                        const errorText = await response.text();
                        console.error('üéµ GlobalPlayer: Resposta de erro:', errorText);
                        // Retornar a URL original como fallback
                        return audioUrl;
                    }
                } else {
                    console.error('üéµ GlobalPlayer: Padr√£o do bucket n√£o encontrado na URL:', audioUrl);
                    // Retornar a URL original como fallback
                    return audioUrl;
                }
            } catch (error) {
                console.error('üéµ GlobalPlayer: Erro ao obter URL segura:', error);
                // Retornar a URL original como fallback
                return audioUrl;
            }
        }

        return audioUrl;
    };

    const playTrack = async (track: Track, newPlaylist?: Track[]) => {
        // Verificar se √© dispositivo m√≥vel
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // Permitir reprodu√ß√£o para todos os usu√°rios (logados e n√£o logados)
        console.log('üéµ GlobalPlayer: Reprodu√ß√£o permitida para todos os usu√°rios');

        // Em mobile, garantir que o √°udio seja reproduzido apenas ap√≥s intera√ß√£o do usu√°rio
        if (isMobile) {
            console.log('üéµ GlobalPlayer: Mobile - garantindo intera√ß√£o do usu√°rio para reprodu√ß√£o');
        }

        // Permitir reprodu√ß√£o para todos os usu√°rios (logados e n√£o logados)
        console.log('üéµ GlobalPlayer: playTrack called with:', {
            id: track.id,
            songName: track.songName,
            downloadUrl: track.downloadUrl,
            previewUrl: track.previewUrl,
            url: track.url,
            imageUrl: track.imageUrl
        });

        // Obter URL segura se necess√°rio
        const secureUrl = await getSecureAudioUrl(track);
        if (!secureUrl) {
            console.error('üéµ GlobalPlayer: No valid audio URL found for track:', track);
            showToast('‚ùå URL de √°udio inv√°lida para esta faixa', 'error');
            return;
        }

        // Verificar se a URL √© v√°lida
        try {
            new URL(secureUrl);
        } catch (error) {
            console.error('üéµ GlobalPlayer: Invalid audio URL:', secureUrl);
            showToast('‚ùå URL de √°udio inv√°lida para esta faixa', 'error');
            return;
        }

        // Se uma nova playlist foi fornecida, atualize a playlist
        if (newPlaylist) {
            setPlaylist(newPlaylist);
            const index = newPlaylist.findIndex(t => t.id === track.id);
            setCurrentTrackIndex(index);
        } else {
            // Se n√£o h√° playlist nova, procure na playlist atual
            const index = playlist.findIndex(t => t.id === track.id);
            setCurrentTrackIndex(index >= 0 ? index : 0);
        }

        setCurrentTrack(track);
        setIsPlaying(true);
    };

    const pauseTrack = () => {
        console.log('üéµ GlobalPlayer: Pausing track');
        setIsPlaying(false);
    };

    const stopTrack = () => {
        console.log('üéµ GlobalPlayer: Stopping and resetting track');
        setIsPlaying(false);
        setCurrentTrack(null);
        setCurrentTrackIndex(-1);
        if (audioRef.current) {
            audioRef.current.pause();
            audioRef.current.currentTime = 0;
        }
    };

    const nextTrack = () => {
        if (playlist.length === 0 || currentTrackIndex === -1) return;

        const nextIndex = (currentTrackIndex + 1) % playlist.length;
        const nextTrackToPlay = playlist[nextIndex];

        if (nextTrackToPlay) {
            setCurrentTrackIndex(nextIndex);
            setCurrentTrack(nextTrackToPlay);
            setIsPlaying(true);
        }
    };

    const previousTrack = () => {
        if (playlist.length === 0 || currentTrackIndex === -1) return;

        const prevIndex = currentTrackIndex === 0 ? playlist.length - 1 : currentTrackIndex - 1;
        const prevTrackToPlay = playlist[prevIndex];

        if (prevTrackToPlay) {
            setCurrentTrackIndex(prevIndex);
            setCurrentTrack(prevTrackToPlay);
            setIsPlaying(true);
        }
    };

    const togglePlayPause = () => {
        if (!currentTrack) return;

        if (isPlaying) {
            pauseTrack();
        } else {
            // Verificar se o √°udio est√° pronto antes de reproduzir
            if (audioRef.current) {
                const audio = audioRef.current;

                // Verificar se o √°udio tem dados carregados
                if (audio.readyState >= 2) { // HAVE_CURRENT_DATA
                    console.log('üéµ GlobalPlayer: Audio ready, starting playback');
                    setIsPlaying(true);
                } else {
                    console.log('üéµ GlobalPlayer: Audio not ready, waiting for data');
                    // Aguardar o carregamento do √°udio
                    const handleCanPlay = () => {
                        console.log('üéµ GlobalPlayer: Audio can play now');
                        setIsPlaying(true);
                        audio.removeEventListener('canplay', handleCanPlay);
                    };
                    audio.addEventListener('canplay', handleCanPlay);
                }
            } else {
                setIsPlaying(true);
            }
        }
    };

    // Effect para controlar o √°udio
    useEffect(() => {
        if (!audioRef.current || !currentTrack) return;

        // Verificar se √© dispositivo m√≥vel
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // Permitir carregamento de √°udio para todos os usu√°rios
        console.log('üéµ GlobalPlayer: Carregando √°udio para todos os usu√°rios');

        const audio = audioRef.current;
        // Priorizar downloadUrl que √© o mesmo link do bot√£o download
        const audioUrl = currentTrack.downloadUrl || currentTrack.previewUrl || currentTrack.url;

        console.log('üéµ GlobalPlayer: Audio effect triggered', {
            trackId: currentTrack.id,
            trackName: currentTrack.songName || currentTrack.title,
        });

        // Fun√ß√£o interna para reproduzir √°udio de forma ass√≠ncrona
        const playAudioAsync = async () => {
            try {
                await audioRef.current?.play();
                setIsPlaying(true);
            } catch (err: any) {
                const url = audioRef.current?.src;
                let msg = "";
                if (err?.name === "NotAllowedError") {
                    msg = "O navegador bloqueou a reprodu√ß√£o autom√°tica. Toque para liberar o √°udio.";
                } else if (err?.name === "NotSupportedError") {
                    msg = "O formato de √°udio pode n√£o ser compat√≠vel com seu dispositivo.";
                } else if (err?.name === "NetworkError") {
                    msg = "Erro de rede ao tentar carregar o √°udio.";
                } else {
                    msg = "Erro ao tentar reproduzir a m√∫sica.";
                }
                showToast(`${msg}\nURL: ${url || "(desconhecida)"}`, "error");
                setIsPlaying(false);
            }
        };

        // Verificar se a URL √© v√°lida
        try {
            new URL(audioUrl);
        } catch (error) {
            console.error('üéµ GlobalPlayer: Invalid audio URL:', audioUrl);
            setIsPlaying(false);
            return;
        }

        // Verificar se a URL n√£o est√° vazia ou √© apenas espa√ßos
        if (!audioUrl.trim()) {
            console.error('üéµ GlobalPlayer: Empty audio URL');
            setIsPlaying(false);
            return;
        }

        // Verificar se a URL parece ser de um servi√ßo de streaming conhecido
        const isStreamingService = /\.(mp3|wav|ogg|m4a|aac)$/i.test(audioUrl) ||
            audioUrl.includes('blob:') ||
            audioUrl.includes('data:audio');

        if (!isStreamingService && !audioUrl.startsWith('http')) {
            console.warn('üéµ GlobalPlayer: Potentially problematic audio URL format:', audioUrl);
        }

        // Chamar a fun√ß√£o ass√≠ncrona ap√≥s as verifica√ß√µes
        playAudioAsync();

        // Fun√ß√£o para tentar reproduzir o √°udio de forma segura
        const playAudioSafely = async (retryCount = 0) => {
            try {
                // Em mobile, tentar reprodu√ß√£o mais direta
                if (isMobile) {
                    console.log('üéµ GlobalPlayer: Mobile - tentando reprodu√ß√£o direta');

                    // Verificar se o √°udio est√° em um estado v√°lido
                    if (audio.error) {
                        console.error('üéµ GlobalPlayer: Mobile - √°udio em erro, tentando reproduzir mesmo assim');
                        // Em mobile, tentar reproduzir mesmo com erro
                    }

                    // Tentar reproduzir imediatamente em mobile
                    try {
                        await audio.play();
                        console.log('üéµ GlobalPlayer: Mobile - reprodu√ß√£o iniciada com sucesso');
                        return;
                    } catch (playError) {
                        console.warn('üéµ GlobalPlayer: Mobile - reprodu√ß√£o direta falhou, tentando m√©todo padr√£o:', playError);

                        // Tratar erro espec√≠fico de autoplay bloqueado em mobile
                        if (playError instanceof Error && playError.name === 'NotAllowedError') {
                            console.error('üéµ GlobalPlayer: Mobile - Autoplay bloqueado! Usu√°rio precisa tocar no bot√£o');
                            showToast('üîá Toque no bot√£o de play para ativar o √°udio no seu dispositivo', 'warning');
                            return;
                        }
                    }
                }

                // Limitar tentativas de retry
                if (retryCount >= 2) {
                    console.error('üéµ GlobalPlayer: Max retry attempts reached');
                    handlePlayError(new Error('M√°ximo de tentativas de reprodu√ß√£o atingido'));
                    return;
                }

                // Verificar se o √°udio est√° em um estado v√°lido
                if (audio.error) {
                    console.error('üéµ GlobalPlayer: Audio has error state, cannot play');
                    handlePlayError(new Error('√Åudio em estado de erro'));
                    return;
                }

                // Verificar se o √°udio est√° pronto para reprodu√ß√£o
                if (audio.readyState >= 2) { // HAVE_CURRENT_DATA ou superior
                    console.log('üéµ GlobalPlayer: Audio ready, starting playback');
                    await audio.play();
                } else {
                    console.log('üéµ GlobalPlayer: Audio not ready, waiting for canplay event');

                    // Aguardar o evento canplay antes de tentar reproduzir
                    const canPlayHandler = () => {
                        // Verificar novamente se n√£o h√° erro antes de reproduzir
                        if (audio.error) {
                            console.error('üéµ GlobalPlayer: Audio error detected while waiting for canplay');
                            handlePlayError(new Error('√Åudio em estado de erro'));
                            return;
                        }

                        audio.play().catch((error: any) => {
                            console.error('üéµ GlobalPlayer: Audio play error after canplay:', {
                                error: error?.message || 'Erro desconhecido',
                                errorName: error?.name,
                                currentTrack: currentTrack?.songName || currentTrack?.title
                            });
                            handlePlayError(error);
                        });
                        audio.removeEventListener('canplay', canPlayHandler);
                    };

                    // Reduzir timeout para 5 segundos e melhorar tratamento
                    const timeoutId = setTimeout(() => {
                        console.warn('üéµ GlobalPlayer: Audio loading timeout, attempting fallback');
                        audio.removeEventListener('canplay', canPlayHandler);

                        // Tentar reproduzir mesmo sem o evento canplay
                        if (audio.readyState >= 1) { // HAVE_METADATA ou superior
                            console.log('üéµ GlobalPlayer: Attempting playback despite timeout');
                            audio.play().catch((error: any) => {
                                console.error('üéµ GlobalPlayer: Fallback play failed:', error);
                                // Tentar retry se ainda n√£o atingiu o limite
                                if (retryCount < 2) {
                                    console.log('üéµ GlobalPlayer: Retrying audio playback...');
                                    setTimeout(() => playAudioSafely(retryCount + 1), 1000);
                                } else {
                                    handlePlayError(new Error('Falha ao reproduzir √°udio ap√≥s timeout'));
                                }
                            });
                        } else {
                            // Tentar retry se ainda n√£o atingiu o limite
                            if (retryCount < 2) {
                                console.log('üéµ GlobalPlayer: Retrying audio loading...');
                                setTimeout(() => playAudioSafely(retryCount + 1), 1000);
                            } else {
                                handlePlayError(new Error('√Åudio n√£o carregou em tempo h√°bil'));
                            }
                        }
                    }, 5000); // Reduzido para 5 segundos

                    audio.addEventListener('canplay', canPlayHandler);

                    // Limpar timeout quando o evento canplay for disparado
                    const timeoutClearedHandler = () => {
                        clearTimeout(timeoutId);
                        audio.removeEventListener('canplay', timeoutClearedHandler);
                    };
                    audio.addEventListener('canplay', timeoutClearedHandler);
                }
            } catch (error: any) {
                console.error('üéµ GlobalPlayer: Audio play error:', {
                    error: error?.message || 'Erro desconhecido',
                    errorName: error?.name,
                    currentTrack: currentTrack?.songName || currentTrack?.title
                });
                handlePlayError(error);
            }
        };

        // Fun√ß√£o para tratar erros de reprodu√ß√£o
        const handlePlayError = (error: any) => {
            // Tratar erros espec√≠ficos
            if (error?.name === 'NotAllowedError') {
                console.error('üéµ GlobalPlayer: User interaction required to play audio');
                // Mostrar toast informativo para o usu√°rio
                if (showToast) {
                    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                    if (isMobile) {
                        showToast('üîá Toque no bot√£o de play para ativar o √°udio no seu dispositivo', 'warning');
                    } else {
                        showToast('üîá Clique no bot√£o de play para reproduzir o √°udio', 'info');
                    }
                }
            } else if (error?.name === 'NotSupportedError') {
                console.error('üéµ GlobalPlayer: Audio format not supported');
                if (showToast) {
                    showToast('Formato de √°udio n√£o suportado', 'error');
                }
            } else if (error?.name === 'NetworkError') {
                console.error('üéµ GlobalPlayer: Network error loading audio');
                if (showToast) {
                    showToast('Erro de rede ao carregar o √°udio', 'error');
                }
            } else if (error?.message?.includes('timeout') || error?.message?.includes('tempo h√°bil')) {
                console.error('üéµ GlobalPlayer: Audio loading timeout');
                if (showToast) {
                    showToast('√Åudio demorou para carregar. Tente novamente.', 'warning');
                }
            } else if (error?.message?.includes('Falha ao reproduzir')) {
                console.error('üéµ GlobalPlayer: Audio playback failed after timeout');
                if (showToast) {
                    showToast('Falha ao reproduzir √°udio. Verifique a conex√£o.', 'error');
                }
            } else {
                console.error('üéµ GlobalPlayer: Unknown audio error:', error);
                if (showToast) {
                    showToast('Erro desconhecido ao reproduzir √°udio', 'error');
                }
            }
            setIsPlaying(false);
        };

        // S√≥ carrega nova URL se for diferente
        if (audio.src !== audioUrl) {
            console.log('üéµ GlobalPlayer: Loading new audio URL:', audioUrl);
            audio.src = audioUrl;
            audio.load();

            // Log adicional para debug
            console.log('üéµ GlobalPlayer: Audio element state after load:', {
                src: audio.src,
                readyState: audio.readyState,
                networkState: audio.networkState,
                error: audio.error,
                paused: audio.paused,
                ended: audio.ended
            });
        }

        // Em mobile, garantir que o volume est√° correto
        if (isMobile) {
            audio.volume = 1.0; // Volume m√°ximo em mobile
            audio.muted = false; // Garantir que n√£o est√° mutado
            console.log('üéµ GlobalPlayer: Mobile - volume configurado:', { volume: audio.volume, muted: audio.muted });
        }

        if (isPlaying) {
            console.log('üéµ GlobalPlayer: Attempting to start audio playback');
            if (isMobile) {
                console.log('üéµ GlobalPlayer: Mobile - iniciando reprodu√ß√£o com URL direta');
            }
            playAudioSafely();
        } else {
            console.log('üéµ GlobalPlayer: Pausing audio');
            audio.pause();
        }
    }, [currentTrack, isPlaying, showToast]);

    // Event listeners para o √°udio
    useEffect(() => {
        if (!audioRef.current) return;

        const audio = audioRef.current;

        const handleEnded = () => {
            console.log('üéµ GlobalPlayer: Track ended, auto-advancing to next track');
            // Automaticamente avan√ßa para a pr√≥xima m√∫sica
            if (playlist.length > 0 && currentTrackIndex >= 0) {
                nextTrack();
            } else {
                setIsPlaying(false);
            }
        };

        const handleError = (e: Event) => {
            const target = e.target as HTMLAudioElement;
            const audioError = target.error;

            // Detectar se √© dispositivo m√≥vel
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

            // Log mais limpo para evitar spam no console
            if (audioError) {
                console.warn('üéµ GlobalPlayer: Audio error in useEffect', {
                    code: audioError.code,
                    message: audioError.message,
                    track: currentTrack?.songName || 'Unknown'
                });
            }

            // Tratar erros espec√≠ficos para mobile vs desktop
            if (isMobile) {
                if (audioError?.code === MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED) {
                    showToast?.('‚ö†Ô∏è Formato de √°udio pode n√£o ser compat√≠vel com seu dispositivo', 'warning');
                } else if (audioError?.code === MediaError.MEDIA_ERR_NETWORK) {
                    showToast?.('üì± Verifique sua conex√£o de internet', 'warning');
                } else if (audioError?.code === MediaError.MEDIA_ERR_ABORTED) {
                    showToast?.('üîá √Åudio interrompido - toque no bot√£o de play novamente', 'info');
                } else {
                    showToast?.('üì± Problema de compatibilidade de √°udio em mobile', 'warning');
                }
            } else {
                // Para desktop, mensagens mais espec√≠ficas
                if (audioError?.code === MediaError.MEDIA_ERR_NETWORK) {
                    showToast?.('‚ùå Erro de rede ao carregar o √°udio', 'error');
                } else if (audioError?.code === MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED) {
                    showToast?.('‚ùå Formato de √°udio n√£o suportado', 'error');
                } else if (audioError?.code === MediaError.MEDIA_ERR_DECODE) {
                    showToast?.('‚ùå Erro ao decodificar o √°udio', 'error');
                } else {
                    showToast?.('‚ùå Erro ao carregar o √°udio', 'error');
                }
            }

            setIsPlaying(false);
        };

        const handleLoadedData = () => {
            console.log('üéµ GlobalPlayer: Audio loadeddata event fired');
            console.log('üéµ GlobalPlayer: Audio state on loadeddata:', {
                readyState: audio.readyState,
                networkState: audio.networkState,
                error: audio.error,
                paused: audio.paused,
                ended: audio.ended,
                currentTime: audio.currentTime,
                duration: audio.duration
            });
        };

        const handleLoadStart = () => {
            console.log('üéµ GlobalPlayer: Audio loadstart event fired');
            console.log('üéµ GlobalPlayer: Audio state on loadstart:', {
                readyState: audio.readyState,
                networkState: audio.networkState,
                error: audio.error,
                paused: audio.paused,
                ended: audio.ended
            });
        };

        const handleCanPlay = () => {
            console.log('üéµ GlobalPlayer: Audio can play event fired');
            console.log('üéµ GlobalPlayer: Audio state on canplay:', {
                readyState: audio.readyState,
                networkState: audio.networkState,
                error: audio.error,
                paused: audio.paused,
                ended: audio.ended,
                currentTime: audio.currentTime,
                duration: audio.duration
            });
        };

        audio.addEventListener('ended', handleEnded);
        audio.addEventListener('error', handleError);
        audio.addEventListener('loadeddata', handleLoadedData);
        audio.addEventListener('loadstart', handleLoadStart);
        audio.addEventListener('canplay', handleCanPlay);

        return () => {
            audio.removeEventListener('ended', handleEnded);
            audio.removeEventListener('error', handleError);
            audio.removeEventListener('loadeddata', handleLoadedData);
            audio.removeEventListener('loadstart', handleLoadStart);
            audio.removeEventListener('canplay', handleCanPlay);
        };
    }, [playlist, currentTrackIndex]);

    // Atualizar a URL do √°udio quando a faixa atual mudar
    useEffect(() => {
        const audio = audioRef.current;
        if (!audio || !currentTrack) return;

        // Obter URL segura para a faixa atual
        getSecureAudioUrl(currentTrack).then(secureUrl => {
            if (secureUrl && audio.src !== secureUrl) {
                console.log('üéµ GlobalPlayer: Atualizando URL do √°udio:', secureUrl);
                audio.src = secureUrl;
                audio.load(); // Recarregar o √°udio com a nova URL
            }
        }).catch(error => {
            console.error('üéµ GlobalPlayer: Erro ao obter URL segura para √°udio:', error);
        });
    }, [currentTrack]);

    return (
        <GlobalPlayerContext.Provider
            value={{
                currentTrack,
                isPlaying,
                playlist,
                currentTrackIndex,
                playTrack,
                pauseTrack,
                stopTrack,
                togglePlayPause,
                nextTrack,
                previousTrack,
                audioRef,
            }}
        >
            {children}
            {/* Audio element global com logs de debug */}
            <audio
                ref={audioRef}
                preload="metadata"
                crossOrigin="anonymous"
                onLoadedData={() => console.log('üéµ GlobalPlayer: Audio loadeddata')}
                onCanPlay={() => console.log('üéµ GlobalPlayer: Audio canplay')}
                onPlay={() => console.log('üéµ GlobalPlayer: Audio play event')}
                onPause={() => console.log('üéµ GlobalPlayer: Audio pause event')}
                onError={(e) => {
                    const target = e.target as HTMLAudioElement;
                    const audioError = target.error;
                    const url = target.src;
                    // Log mais limpo para evitar spam no console
                    if (audioError) {
                        console.warn('üéµ GlobalPlayer: Audio error detected', {
                            code: audioError.code,
                            message: audioError.message,
                            track: currentTrack?.songName || 'Unknown',
                            url
                        });
                    }
                    // Toast sempre mostra a URL
                    let msg = '';
                    if (audioError?.code === MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED) {
                        msg = '‚ö†Ô∏è Formato de √°udio pode n√£o ser compat√≠vel com seu dispositivo';
                    } else if (audioError?.code === MediaError.MEDIA_ERR_NETWORK) {
                        msg = '‚ùå Erro de rede ao carregar o √°udio';
                    } else if (audioError?.code === MediaError.MEDIA_ERR_ABORTED) {
                        msg = 'üîá √Åudio interrompido - toque no bot√£o de play novamente';
                    } else {
                        msg = '‚ùå Erro ao carregar o √°udio';
                    }
                    showToast(`${msg}\nURL: ${url || '(desconhecida)'}`, audioError?.code === MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED ? 'warning' : 'error');
                    setIsPlaying(false);
                }}
                onEnded={() => console.log('üéµ GlobalPlayer: Audio ended')}
                onAbort={() => console.log('üéµ GlobalPlayer: Audio loading aborted')}
                onSuspend={() => console.log('üéµ GlobalPlayer: Audio loading suspended')}
                onStalled={() => console.log('üéµ GlobalPlayer: Audio stalled')}
                onWaiting={() => console.log('üéµ GlobalPlayer: Audio waiting for data')}
                onLoadStart={() => {
                    console.log('üéµ GlobalPlayer: Audio loadstart event');
                }}
            />
        </GlobalPlayerContext.Provider>
    );
};

export const useGlobalPlayer = () => {
    const context = useContext(GlobalPlayerContext);
    if (context === undefined) {
        throw new Error('useGlobalPlayer must be used within a GlobalPlayerProvider');
    }
    return context;
};
