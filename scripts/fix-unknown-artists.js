const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();

/**
 * Script para corrigir registros com "Artista Desconhecido" no banco de dados
 * 
 * Este script:
 * 1. Identifica todas as m√∫sicas com artistas inv√°lidos
 * 2. Tenta extrair o nome do artista do nome da m√∫sica
 * 3. Atualiza o banco de dados com os nomes corretos
 * 4. Gera um relat√≥rio das corre√ß√µes feitas
 */

// Padr√µes para extrair nomes de artistas de nomes de m√∫sicas
const artistPatterns = [
    // Padr√£o: "ARTISTA - Nome da M√∫sica"
    /^([^-]+)\s*-\s*(.+)$/i,

    // Padr√£o: "ARTISTA ft. FEATURED - Nome da M√∫sica"
    /^([^-]+)\s+ft\.?\s*([^-]+)\s*-\s*(.+)$/i,

    // Padr√£o: "ARTISTA feat. FEATURED - Nome da M√∫sica"
    /^([^-]+)\s+feat\.?\s*([^-]+)\s*-\s*(.+)$/i,

    // Padr√£o: "ARTISTA & FEATURED - Nome da M√∫sica"
    /^([^-]+)\s*&\s*([^-]+)\s*-\s*(.+)$/i,

    // Padr√£o: "ARTISTA x FEATURED - Nome da M√∫sica"
    /^([^-]+)\s*x\s*([^-]+)\s*-\s*(.+)$/i,

    // Padr√£o: "ARTISTA vs FEATURED - Nome da M√∫sica"
    /^([^-]+)\s+vs\s*([^-]+)\s*-\s*(.+)$/i,

    // Padr√£o: "ARTISTA (feat. FEATURED) - Nome da M√∫sica"
    /^([^-]+)\s*\(feat\.?\s*([^)]+)\)\s*-\s*(.+)$/i,

    // Padr√£o: "ARTISTA [feat. FEATURED] - Nome da M√∫sica"
    /^([^-]+)\s*\[feat\.?\s*([^\]]+)\]\s*-\s*(.+)$/i,
];

// Valores inv√°lidos que precisam ser corrigidos
const invalidArtistValues = [
    'Artista Desconhecido',
    'Artista Desconhecido',
    'Unknown Artist',
    'N/A',
    'Unknown',
    'Desconhecido',
    'N√£o Informado',
    'Sem Informa√ß√£o',
    'TBD',
    'To Be Determined'
];

// Fun√ß√£o para extrair nome do artista do nome da m√∫sica
function extractArtistFromSongName(songName) {
    if (!songName) return null;

    // Tentar cada padr√£o
    for (const pattern of artistPatterns) {
        const match = songName.match(pattern);
        if (match) {
            // Retornar o primeiro artista (antes do h√≠fen)
            let artist = match[1].trim();

            // Limpar o nome do artista
            artist = artist
                .replace(/^\s+|\s+$/g, '') // Remove espa√ßos extras
                .replace(/\s+/g, ' ') // Remove m√∫ltiplos espa√ßos
                .replace(/^["']|["']$/g, ''); // Remove aspas

            // Verificar se o artista n√£o √© muito curto ou muito longo
            if (artist.length >= 2 && artist.length <= 100) {
                return artist;
            }
        }
    }

    return null;
}

// Fun√ß√£o para limpar e normalizar nome do artista
function cleanArtistName(artistName) {
    if (!artistName) return null;

    return artistName
        .trim()
        .replace(/\s+/g, ' ') // Remove m√∫ltiplos espa√ßos
        .replace(/^["']|["']$/g, '') // Remove aspas
        .replace(/^\s+|\s+$/g, ''); // Remove espa√ßos extras
}

// Fun√ß√£o principal para corrigir artistas
async function fixUnknownArtists() {
    console.log('üéµ Iniciando corre√ß√£o de artistas desconhecidos...\n');

    try {
        // 1. Buscar todas as m√∫sicas com artistas inv√°lidos
        console.log('üîç Buscando m√∫sicas com artistas inv√°lidos...');

        const tracksWithInvalidArtists = await prisma.track.findMany({
            where: {
                OR: [
                    { artist: { in: invalidArtistValues } },
                    { artist: null },
                    { artist: '' }
                ]
            },
            select: {
                id: true,
                songName: true,
                artist: true,
                style: true,
                pool: true
            }
        });

        console.log(`üìä Encontradas ${tracksWithInvalidArtists.length} m√∫sicas com artistas inv√°lidos\n`);

        if (tracksWithInvalidArtists.length === 0) {
            console.log('‚úÖ Nenhuma m√∫sica com artista inv√°lido encontrada!');
            return;
        }

        // 2. Processar cada m√∫sica
        let correctedCount = 0;
        let failedCount = 0;
        const corrections = [];
        const failures = [];

        console.log('üîÑ Processando m√∫sicas...\n');

        for (const track of tracksWithInvalidArtists) {
            console.log(`üéµ Processando: "${track.songName}" (ID: ${track.id})`);

            try {
                // Tentar extrair artista do nome da m√∫sica
                let newArtistName = extractArtistFromSongName(track.songName);

                // Se n√£o conseguiu extrair, tentar outras estrat√©gias
                if (!newArtistName) {
                    // Estrat√©gia: usar o nome da m√∫sica como artista (√∫ltimo recurso)
                    if (track.songName && track.songName.length > 0) {
                        newArtistName = track.songName.split(' ').slice(0, 3).join(' '); // Primeiras 3 palavras
                        console.log(`   ‚ö†Ô∏è  Usando nome da m√∫sica como artista: "${newArtistName}"`);
                    }
                }

                if (newArtistName) {
                    // Limpar e normalizar o nome
                    newArtistName = cleanArtistName(newArtistName);

                    if (newArtistName && newArtistName.length >= 2) {
                        // Atualizar no banco de dados
                        await prisma.track.update({
                            where: { id: track.id },
                            data: { artist: newArtistName }
                        });

                        corrections.push({
                            id: track.id,
                            oldArtist: track.artist || 'NULL/VAZIO',
                            newArtist: newArtistName,
                            songName: track.songName
                        });

                        correctedCount++;
                        console.log(`   ‚úÖ Corrigido: "${track.artist || 'NULL'}" ‚Üí "${newArtistName}"`);
                    } else {
                        throw new Error('Nome do artista muito curto ap√≥s limpeza');
                    }
                } else {
                    throw new Error('N√£o foi poss√≠vel extrair nome do artista');
                }

            } catch (error) {
                console.log(`   ‚ùå Erro: ${error.message}`);
                failures.push({
                    id: track.id,
                    songName: track.songName,
                    currentArtist: track.artist || 'NULL/VAZIO',
                    error: error.message
                });
                failedCount++;
            }

            console.log(''); // Linha em branco para separar
        }

        // 3. Gerar relat√≥rio
        console.log('üìã RELAT√ìRIO DE CORRE√á√ïES');
        console.log('='.repeat(50));
        console.log(`‚úÖ M√∫sicas corrigidas: ${correctedCount}`);
        console.log(`‚ùå Falhas: ${failedCount}`);
        console.log(`üìä Total processado: ${tracksWithInvalidArtists.length}`);
        console.log('');

        if (corrections.length > 0) {
            console.log('üéØ CORRE√á√ïES REALIZADAS:');
            console.log('-'.repeat(50));
            corrections.forEach((correction, index) => {
                console.log(`${index + 1}. ID ${correction.id}: "${correction.oldArtist}" ‚Üí "${correction.newArtist}"`);
                console.log(`   M√∫sica: "${correction.songName}"`);
                console.log('');
            });
        }

        if (failures.length > 0) {
            console.log('‚ö†Ô∏è  FALHAS:');
            console.log('-'.repeat(50));
            failures.forEach((failure, index) => {
                console.log(`${index + 1}. ID ${failure.id}: "${failure.songName}"`);
                console.log(`   Artista atual: "${failure.currentArtist}"`);
                console.log(`   Erro: ${failure.error}`);
                console.log('');
            });
        }

        // 4. Salvar relat√≥rio em arquivo
        const fs = require('fs');
        const reportData = {
            timestamp: new Date().toISOString(),
            summary: {
                totalProcessed: tracksWithInvalidArtists.length,
                corrected: correctedCount,
                failed: failedCount
            },
            corrections: corrections,
            failures: failures
        };

        const reportPath = `artist-correction-report-${Date.now()}.json`;
        fs.writeFileSync(reportPath, JSON.stringify(reportData, null, 2));
        console.log(`üìÑ Relat√≥rio salvo em: ${reportPath}`);

    } catch (error) {
        console.error('üí• Erro durante a execu√ß√£o:', error);
        throw error;
    }
}

// Fun√ß√£o para verificar estat√≠sticas antes e depois
async function checkDatabaseStats() {
    console.log('üìä VERIFICANDO ESTAT√çSTICAS DO BANCO...\n');

    try {
        // Antes da corre√ß√£o
        const beforeStats = await prisma.track.groupBy({
            by: ['artist'],
            where: {
                OR: [
                    { artist: { in: invalidArtistValues } },
                    { artist: null },
                    { artist: '' }
                ]
            },
            _count: true
        });

        console.log('üîç ANTES da corre√ß√£o:');
        beforeStats.forEach(stat => {
            console.log(`   "${stat.artist || 'NULL/VAZIO'}": ${stat._count} m√∫sicas`);
        });

        console.log('');

        // Executar corre√ß√£o
        await fixUnknownArtists();

        console.log('\n' + '='.repeat(60));

        // Depois da corre√ß√£o
        const afterStats = await prisma.track.groupBy({
            by: ['artist'],
            where: {
                OR: [
                    { artist: { in: invalidArtistValues } },
                    { artist: null },
                    { artist: '' }
                ]
            },
            _count: true
        });

        console.log('üîç DEPOIS da corre√ß√£o:');
        if (afterStats.length === 0) {
            console.log('   ‚úÖ Nenhuma m√∫sica com artista inv√°lido encontrada!');
        } else {
            afterStats.forEach(stat => {
                console.log(`   "${stat.artist || 'NULL/VAZIO'}": ${stat._count} m√∫sicas`);
            });
        }

    } catch (error) {
        console.error('üí• Erro ao verificar estat√≠sticas:', error);
        throw error;
    }
}

// Fun√ß√£o para executar o script
async function main() {
    try {
        console.log('üöÄ SCRIPT DE CORRE√á√ÉO DE ARTISTAS DESCONHECIDOS');
        console.log('='.repeat(60));
        console.log('Este script ir√° corrigir registros com artistas inv√°lidos no banco de dados.');
        console.log('Certifique-se de ter um backup antes de executar!\n');

        // Verificar conex√£o com banco
        await prisma.$connect();
        console.log('‚úÖ Conectado ao banco de dados\n');

        // Executar corre√ß√£o com estat√≠sticas
        await checkDatabaseStats();

        console.log('\nüéâ Script executado com sucesso!');

    } catch (error) {
        console.error('üí• Erro fatal:', error);
        process.exit(1);
    } finally {
        await prisma.$disconnect();
        console.log('üîå Desconectado do banco de dados');
    }
}

// Executar se chamado diretamente
if (require.main === module) {
    main();
}

module.exports = {
    fixUnknownArtists,
    checkDatabaseStats,
    extractArtistFromSongName,
    cleanArtistName
};
